

[[['TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("test")\\\'\', \'None\']]\'', [['TOTAL_ARGUMENT == \'print("test")\'', 'None']]]]]

[
	[
		['TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("test")\\\'\', \'None\']]\'', [['TOTAL_ARGUMENT == \'print("test")\'', 'None']]]
		]
	]

print(TotalSI([[[['1','1'],['2','2'],['3','3']],[['1','1'],['2','2'],['4','4']]],"Auto","all"]))
print(TotalSI([[[[['1','1'],['2','2'],['3','3']],[['1','1'],['2','2'],['3','3']]],[[['1','1'],['2','2'],['3','4']],[['1','1'],['2','2'],['3','4']]]],"Auto","all"]))


[[[['1','1'],['2','2'],['3','3']],[['1','1'],['2','2'],['3','3']]],[[['1','1'],['2','2'],['3','4']],[['1','1'],['2','2'],['3','4']]]]




[['argument_1==\'print("I\'m dying")\'', 'print("I\'m dying")']]

[['Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("', 'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("'], ['α0', 'α0'], ['")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)', '")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)']]
[["['", "['"], ['α0', 'α0'], ["\\n']\n", "\\n']\n"]]

[['α1'], ['α1']], [["\\n']\n"], ["\\n']\n"]]]



>>> delta2([])
[[["['"], ["['"]], [['bukD'], ['bukD']], [['α0'], ['α0']], [['n'], ['n']], [['α1'], ['α1']]]
>>> delta2([])


delta2(['Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("bukD")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)' + "," + "['bukD\\n']\n",'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("rascal")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)' + "," + "['rascal\\n']\n"])


>>> delta2(['Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("bukD")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True), ', 'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("rascal")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)'])
[[['Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("'], ['Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("']], [['α0'], ['α0']], [['")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)'], ['")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)']]]
>>> delta2(["['bukD\\n']\n","['rascal\\n']\n"])
[[["['"], ["['"]], [['α0'], ['α0']], [["\\n']\n"], ["\\n']\n"]]]
>>> 


"[[" + 'TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("f")\\\'\', \'None\']]\'' + ", [[" + 'TOTAL_ARGUMENT == \'print("f")\'' + "," + 'None' + "]]]]"
"[[" + 'TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("r")\\\'\', \'None\']]\'' + ", [[" + 'TOTAL_ARGUMENT == \'print("r")\'' + "," + 'None' + "]]]]"


delta2(["[[" + 'TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("f")\\\'\', \'None\']]\'' + ", [[" + 'TOTAL_ARGUMENT == \'print("f")\'' + "," + 'None' + "]]]]","[[" + 'TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("r")\\\'\', \'None\']]\'' + ", [[" + 'TOTAL_ARGUMENT == \'print("r")\'' + "," + 'None' + "]]]]"])
[[['[[TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("'], ['[[TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("']], [['α0'], ['α0']], [['")\\\'\', \'None\']]\', [[TOTAL_ARGUMENT == \'print("'], ['")\\\'\', \'None\']]\', [[TOTAL_ARGUMENT == \'print("']], [['α1'], ['α1']]]

[
[['[[TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("'], ['[[TOTAL_ARGUMENT == \'[[\'TOTAL_ARGUMENT == \\\'print("']], 
[['α0'], ['α0']], 
[['")\\\'\', \'None\']]\', [[TOTAL_ARGUMENT == \'print("'], ['")\\\'\', \'None\']]\', [[TOTAL_ARGUMENT == \'print("']], 
[['α1'], ['α1']]
]


"[[" + 'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("f")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)' + ", [" + "['f\\n']\n" + "]]]"
"[[" + 'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("r")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)' + ", [" + "['r\\n']\n" + "]]]"

delta2(["[[" + 'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("f")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)' + ", [" + "['f\\n']\n" + "]]]","[[" + 'Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("r")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)' + ", [" + "['r\\n']\n" + "]]]"])

[
[['[[Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("'], ['[[Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("']],
[['α0'], ['α0']], 
[["\\n']\n]]]"], ["\\n']\n]]]"]], 
[['")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True), [[\''], ['")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True), [[\'']], 
[['α1'], ['α1']]
]




[['Popen([\'python\',C:\\An\\MIRA\\Mira.py, print("f")], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True)', ["['f\\n']\n"]]]


TEST X, Y
x = [['1','1'],['2','2'],['3','3']]
y = [['1','1'],['2','2'],['3','3']]

ShittySI([[[['1','1'],['2','2'],['3','3']],[['1','1'],['2','2'],['3','3']]],"Auto","all"])

def ShittySI(ListItems):
    '''
	ShittySI([[GraphX,GraphY],"Auto" OR EMPTY, "all" or EMPTY])
    NOTE: THIS IS BIDIRECTIONAL ACTUALLY!! SO SAYS YES IF E_G SI E_H OR E_H SI E_G!
    input is a list of the form: [[E_G,E_H], "Auto"]
    says if E_G SI to some E_J in E_H
    '''
    E_G = ListItems[0][0]
    E_H = ListItems[0][1]
	try:
		ALLTRIGGER = ListItems[2]
	except:
		ALLTRIGGER = ""
    #if they're exact same they're SI
    if E_G == E_H:
        return [True, "same" ]
    #else:
    if len(E_G) < len(E_H):
        WLOG = E_G
        Larger = E_H
    else:
        WLOG = E_H
        Larger = E_G

    #print("REMEMBER TO ADD ZEROLINKS TO EDGESORTbyLINKS")
    #print("sort by links START")
    #print(WLOG)
    #print(Larger)
    #print(EdgeSortbyLinks(WLOG))
    #print(EdgeSortbyLinks(Larger))
    #print(LinkPoolGen(EdgeSortbyLinks(WLOG),EdgeSortbyLinks(Larger)))
    #print("sort by links END")

    LinkPool = LinkPoolGen(EdgeSortbyLinks(WLOG),EdgeSortbyLinks(Larger))
    
    #add Zerolinks to LinkPoolGen
    #a zeronode is a node that doesn't actually link to anything (just recieves links in the graph)
    #just check LinkPool VS Vertex_(WLOG)
    #print("ran keys",ranDict(LinkPool)) 
    ZeroNodes = [x for x in Vertex_(WLOG) if x not in ranDict(LinkPool)]
    #print("Zeronodes?",ZeroNodes) 
    for x in ZeroNodes:
        LinkPool[x] = Vertex_(Larger)
    #print("LinkPool+Zeronodes?",LinkPool)

    #make sure LinkPool lists contain each other when you go down the list
    LinkPoolList = []
    #print("OK LINKPOOL BETTER NOT BE FUCKED",LinkPool)
    for x in LinkPool:
        #print("LPL START======",LinkPoolList)
        #print("what is X START",x)
        if len(LinkPoolList) == 0:
            LinkPoolList.append([x,LinkPool[x]])
            #print("WHEN DOES LPL CHANGE",LinkPoolList)
        else:
            for y in LinkPoolList:
                Linked = False
                #print("stats", LinkPoolList)
                #print("y",y)
                ##"new object length is smaller, you add it to keep connection lengths similar"
                #print("I don't understand <=", len(LinkPool[x]),len(y[1]))
                if len(LinkPool[x]) <= len(y[1]):
                    #print("GOT ADDED ALREADY WTF",LinkPoolList)
                    LinkPoolList = InsertAt(LinkPoolList,[x,LinkPool[x]],LinkPoolList.index(y)) 
                    #print("LPL Insert",LinkPoolList)
                    Linked = True
                    break
                #append at end if largest
                if Linked == False:
                    LinkPoolList = LinkPoolList + [[x,LinkPool[x]]]
                    #print("WHEN DOES LPL CHANGE2",LinkPoolList)
                    break
        #print("LPL END=======",LinkPoolList)
    #print("check LinkPoolList",LinkPoolList)

    LinkSize = []
    LinkList = []
    #LinkSize is the size of each list in LinkPool
    #need to subtract 1 each time we append to LinkSize because we are making a choice and excluding them from the rest
    #LinkPool is the corresponding list at the right index
    i = 0
    for x in LinkPoolList:
        LinkSize.append(len(x[1])-i)
        i += 1
        LinkList.append(x[1])
    #print("check linksize",LinkSize)
    #print("check linklist",LinkList)

    #print("DOUBLE CHECK LINKPOOL START")
    #print("smaller", WLOG)
    #print("larger", Larger)
    #print(LinkPool)
    #print("DOUBLE CHECK LINKPOOL END")

    AutoCheck = IsAuto(WLOG) and IsAuto(Larger)
    #print("what is LinkPoolList?",LinkPoolList)
    
    NumberIndex = []
	ANS = []
    for G in LinkSize:
        if len(NumberIndex) > 0:
            NumberNew = []
            for H in range(0,G):
                for J in NumberIndex:
                    Appendage = J + [H]
                    NumberNew.append(Appendage)
                    if len(Appendage) == len(LinkPool):
                        Indexer = []
                        #Phiconstruct needs Indsx ran: [node,elem]
                        i = 0
                        for K in Appendage:
                            Indexer.append([LinkPoolList[i][0],Appendage[i]])
                            i += 1
                        #print("here we test SI iwth",Appendage)
                        #print("Indexer is", Indexer)
                        #print("PhiConstruct",PhiConstruct(Indexer,LinkPool,AutoCheck))
                        #If |V_H| > |V_G|, then construct H* to use instead:
                        if len(Vertex_(Larger)) > len(Vertex_(WLOG)):
                            #H* is the list of pairs in E_H s.t. indexer \circ phi doesn't fail:
                            HStar = []
                            for L in Larger:
                                passA = True
                                passB = True
                                if len(RelEval(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,False)),L[0])) == 0:
                                    passA = False
                                if len(RelEval(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,False)),L[1])) == 0:
                                    passB = False
                                if passA == True and passB == True:
                                    HStar.append(L)
                            #print("ok check out H*!",HStar)
                        else:
                            HStar = Larger

                        tryit = True
                        try: 
                            ListItems[1]
                        except IndexError:
                            tryit = False
                        if tryit == True:
                            if ListItems[1] == "Auto":
                                Vertex_Max = '0'
                                #print("vertexmax lolwut",Vertex_(WLOG) + Vertex_(Larger))
                                for NUM in Vertex_(WLOG) + Vertex_(Larger):
                                    if int(NUM) > int(Vertex_Max):
                                        Vertex_Max = str(NUM)
                                #print("V_G",Vertex_(WLOG))
                                #print("V_H",Vertex_(Larger))
                                #print("TheMax",Vertex_Max)
                                #print("parts for AD1",WLOG)
                                #print("Larger",Larger)
                                #print("Indexer",Indexer)
                                #print("LinkPool",LinkPool)
                                #print("PhiConstruct",PhiConstruct(Indexer,LinkPool,AutoCheck))
                                #print("need to pick right max",rchiINT(Vertex_Max))
                                #print("basis",Minv_(rchiINT(Vertex_Max)))
                                #print("compose",Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)))

                                if len(Vertex_(Larger)) >= len(Vertex_(WLOG)):
                                    #H* is the list of pairs in E_H s.t. indexer \circ phi doesn't fail:
                                    HStar = []
                                    for L in Larger:
                                        passA = True
                                        passB = True
                                        if len(RelEval(Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,False)),L[0])) == 0:
                                            passA = False
                                        if len(RelEval(Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,False)),L[1])) == 0:
                                            passB = False
                                        if passA == True and passB == True:
                                            HStar.append(L)
                                    #print("ok check out H*!",HStar)
                                else:
                                    HStar = Larger
                                #print("DATA =======")
                                #print("smaller", WLOG)
                                #print("Larger", Larger)
                                #print("Vertex_Max",Vertex_Max)
                                #print("rchiINT",rchiINT(Vertex_Max))
                                #print("Minv_",Minv_(rchiINT(Vertex_Max)))
                                #print("Indexer IS THE PROBLEM",Indexer)
                                #print("LinkPool",LinkPool)
                                #print("AutoCheck",AutoCheck)
                                #print("phi",PhiConstruct(Indexer,LinkPool,AutoCheck))
                                #print("Compose",Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)))
                                #print("DATA END =-=========")
                                #print("=======died at 100MB", Minv_(rchiINT(Vertex_Max)))
                                #print("more stats", PhiConstruct(Indexer,LinkPool,AutoCheck))
                                #print("ok?",Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)))

                                AD1 = AddressFunc(Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                                AD2 = AddressFunc(Minv_(rchiINT(Vertex_Max)),HStar)
                                #print("stats")
                                #print(Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                                #print(Minv_(rchiINT(Vertex_Max)),HStar)
                                #print("AD checks prior",AD1,AD2)
                                #print("======= DIED END")
                            else:
                                #time to check SI:
                                AD1 = AddressFunc(Compose(Minv_(Beta_(HStar)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                                AD2 = AddressFunc(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,AutoCheck)),HStar)
                        else:
                            #time to check SI:
                            AD1 = AddressFunc(Compose(Minv_(Beta_(HStar)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                            AD2 = AddressFunc(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,AutoCheck)),HStar)
                        #print("ADchecks",AD1,AD2)
                        #print("tobin AD1","{0:b}".format(AD1)[::-1])
                        #print("tobin AD2","{0:b}".format(AD2)[::-1])
                        #print("LessthanC",LessThan_C(AD1,AD2)) 
						if LessThan_C(AD1,AD2) and len(ALLTRIGGER) == 0:
                            return [True,PhiConstruct(Indexer,LinkPool,AutoCheck)]
						elif ANS[0] == True:
							ANS.append(hiConstruct(Indexer,LinkPool,AutoCheck))
						else:
							ANS.append(True,PhiConstruct(Indexer,LinkPool,AutoCheck))
            NumberIndex = NumberNew
        else:
            for H in range(0,G):
                NumberIndex.append([H])
                if len(LinkList) == 1:
                    #print("should test tiny SI with",NumberIndex)
                    Indexer = []
                    #Phiconstruct needs Indsx ran: [node,elem]
                    i = 0
                    for K in range(0,len(LinkList)):
                        Indexer.append([LinkPoolList[i][0],H])
                        i += 1
                    #print("Indexer is ", Indexer)
                    #print("Phiconstruct",PhiConstruct(Indexer,LinkPool,AutoCheck))
                    #If |V_H| > |V_G|, then construct H* to use instead:
                    if len(Vertex_(Larger)) > len(Vertex_(WLOG)):
                        #H* is the list of pairs in E_H s.t. indexer \circ phi doesn't fail:
                        HStar = []
                        for L in Larger:
                            passA = True
                            passB = True
                            if len(RelEval(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,False)),L[0])) == 0:
                                passA = False
                            if len(RelEval(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,False)),L[1])) == 0:
                                passB = False
                            if passA == True and passB == True:
                                HStar.append(L)
                        #print("ok check out H*!",HStar)
                    else:
                        HStar = Larger
                    tryit = True
                    try: 
                        ListItems[1]
                    except IndexError:
                        tryit = False
                    if tryit == True:
                        if ListItems[1] == "Auto":
                            Vertex_Max = '0'
                            for NUM in Vertex_(WLOG) + Vertex_(Larger):
                                if int(NUM) > int(Vertex_Max):
                                    Vertex_Max = str(NUM)
                            #print("parts for AD1",WLOG)
                            #print("Larger",Larger)
                            #print("Indexer",Indexer)
                            #print("LinkPool",LinkPool)
                            #print("PhiConstruct",PhiConstruct(Indexer,LinkPool,AutoCheck))
                            #print("basis",Minv_(rchiINT(Vertex_Max)))
                            #print("compose",Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)))
                            AD1 = AddressFunc(Compose(Minv_(rchiINT(Vertex_Max)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                            AD2 = AddressFunc(Minv_(rchiINT(Vertex_Max)),HStar)
                        else:
                            #time to check SI:
                            AD1 = AddressFunc(Compose(Minv_(Beta_(HStar)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                            AD2 = AddressFunc(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,AutoCheck)),HStar)
                    else:
                        #time to check SI:
                        AD1 = AddressFunc(Compose(Minv_(Beta_(HStar)),PhiConstruct(Indexer,LinkPool,AutoCheck)),WLOG)
                        AD2 = AddressFunc(Compose(Minv_(Beta_(WLOG)),PhiConstruct(Indexer,LinkPool,AutoCheck)),HStar) 
                    #print("ADchecks",AD1,AD2)
                    #print("tobin AD1","{0:b}".format(AD1)[::-1])
                    #print("tobin AD2","{0:b}".format(AD2)[::-1])
                    #print("LessthanC",LessThan_C(AD1,AD2))
					
					if LessThan_C(AD1,AD2) and len(ALLTRIGGER) == 0:
						return [True,PhiConstruct(Indexer,LinkPool,AutoCheck)]
					elif ANS[0] == True:
						ANS.append(hiConstruct(Indexer,LinkPool,AutoCheck))
					else:
						ANS.append(True,PhiConstruct(Indexer,LinkPool,AutoCheck))
	if len(ANS) > 0:
		return [True, ANS]
    return ["Assume False"]